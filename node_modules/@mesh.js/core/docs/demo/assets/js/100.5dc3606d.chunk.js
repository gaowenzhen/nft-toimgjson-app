(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{525:function(e,n,t){"use strict";t.r(n),n.default="const {Renderer, Figure2D} = meshjs;\nconst canvas = document.querySelector('canvas');\n\n/* globals Proton, MeshRenderer */\nconst proton = new Proton();\nconst emitter = new Proton.Emitter();\n\n// set Rate\nemitter.rate = new Proton.Rate(Proton.getSpan(10, 20), 0.1);\n\n// add Initialize\nemitter.addInitialize(new Proton.Radius(1, 12));\nemitter.addInitialize(new Proton.Life(2, 4));\nemitter.addInitialize(new Proton.Velocity(3, Proton.getSpan(0, 360), 'polar'));\n\n// add Behaviour\nemitter.addBehaviour(new Proton.Color('#ff0000', 'random'));\nemitter.addBehaviour(new Proton.Alpha(1, 0));\nemitter.addBehaviour(new Proton.Rotate());\n\n// set emitter position\nemitter.p.x = canvas.width / 2;\nemitter.p.y = canvas.height / 2;\nemitter.emit(5);\n\n// add emitter to the proton\nproton.addEmitter(emitter);\n\n// add renderer\nconst renderer = new Renderer(canvas);\nconst figure = new Figure2D();\nfigure.rect(-0.5, -0.5, 1, 1);\nemitter.addInitialize(new Proton.Body(figure));\nconst meshRenderer = new MeshRenderer(renderer);\nproton.addRenderer(meshRenderer);\n// const canvasRenderer = new Proton.CanvasRenderer(canvas);\n// proton.addRenderer(canvasRenderer);\n\n// use Euler integration calculation is more accurate (default false)\nProton.USE_CLOCK = false;\n// proton.update()\nfunction tick() {\n  requestAnimationFrame(tick);\n  proton.update();\n}\ntick();"}}]);